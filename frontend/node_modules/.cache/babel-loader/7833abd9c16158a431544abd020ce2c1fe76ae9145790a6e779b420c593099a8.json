{"ast":null,"code":"/**\n * Audio Recorder Utility\n * Handles microphone access, recording, and audio chunk processing\n */export class AudioRecorder{constructor(){this.mediaRecorder=null;this.audioContext=null;this.stream=null;this.chunks=[];this.isRecording=false;}/**\n   * Initialize and request microphone access\n   * @returns {Promise<MediaStream>}\n   */async init(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:{channelCount:1,sampleRate:16000,echoCancellation:true,noiseSuppression:true}});return this.stream;}catch(error){console.error('Failed to access microphone:',error);throw new Error('Não foi possível acessar o microfone. Verifique as permissões.');}}/**\n   * Start recording\n   * @param {Function} onDataAvailable - Callback when audio chunk is ready\n   * @param {number} timeSlice - Time between chunks in milliseconds (default: 1000ms)\n   */startRecording(onDataAvailable){let timeSlice=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1000;if(!this.stream){throw new Error('Microphone not initialized. Call init() first.');}this.chunks=[];this.mediaRecorder=new MediaRecorder(this.stream,{mimeType:'audio/webm;codecs=opus'});this.mediaRecorder.ondataavailable=event=>{if(event.data.size>0){this.chunks.push(event.data);if(onDataAvailable){onDataAvailable(event.data);}}};this.mediaRecorder.start(timeSlice);this.isRecording=true;}/**\n   * Stop recording and return the complete audio blob\n   * @returns {Promise<Blob>}\n   */stopRecording(){return new Promise((resolve,reject)=>{if(!this.mediaRecorder||!this.isRecording){reject(new Error('No active recording'));return;}this.mediaRecorder.onstop=()=>{const blob=new Blob(this.chunks,{type:'audio/webm;codecs=opus'});this.isRecording=false;resolve(blob);};this.mediaRecorder.stop();});}/**\n   * Get audio level for visualization\n   * @returns {Promise<number>} Volume level (0-100)\n   */async getAudioLevel(){if(!this.stream){return 0;}if(!this.audioContext){this.audioContext=new(window.AudioContext||window.webkitAudioContext)();}const source=this.audioContext.createMediaStreamSource(this.stream);const analyser=this.audioContext.createAnalyser();analyser.fftSize=256;source.connect(analyser);const dataArray=new Uint8Array(analyser.frequencyBinCount);analyser.getByteFrequencyData(dataArray);// Calculate average volume\nconst average=dataArray.reduce((a,b)=>a+b)/dataArray.length;return Math.min(100,average/128*100);}/**\n   * Start continuous audio level monitoring\n   * @param {Function} callback - Called with audio level (0-100)\n   * @param {number} interval - Update interval in milliseconds\n   * @returns {number} Interval ID for clearing\n   */startAudioLevelMonitoring(callback){let interval=arguments.length>1&&arguments[1]!==undefined?arguments[1]:100;if(!this.audioContext){this.audioContext=new(window.AudioContext||window.webkitAudioContext)();}const source=this.audioContext.createMediaStreamSource(this.stream);const analyser=this.audioContext.createAnalyser();analyser.fftSize=256;source.connect(analyser);const dataArray=new Uint8Array(analyser.frequencyBinCount);const intervalId=setInterval(()=>{analyser.getByteFrequencyData(dataArray);const average=dataArray.reduce((a,b)=>a+b)/dataArray.length;const level=Math.min(100,average/128*100);callback(level);},interval);return intervalId;}/**\n   * Convert audio blob to WAV format\n   * @param {Blob} blob - Input audio blob\n   * @returns {Promise<Blob>} WAV formatted blob\n   */async convertToWav(blob){// For simplicity, we'll send the webm directly to backend\n// The backend can handle webm format\n// If you need true WAV conversion, you'd need to decode and re-encode\nreturn blob;}/**\n   * Clean up resources\n   */cleanup(){if(this.mediaRecorder&&this.isRecording){this.mediaRecorder.stop();}if(this.stream){this.stream.getTracks().forEach(track=>track.stop());}if(this.audioContext){this.audioContext.close();}this.mediaRecorder=null;this.audioContext=null;this.stream=null;this.chunks=[];this.isRecording=false;}}/**\n * Simple audio level visualization\n * @param {number} level - Audio level (0-100)\n * @returns {string} Visual representation\n */export function visualizeAudioLevel(level){const bars=Math.floor(level/10);return'█'.repeat(bars)+'░'.repeat(10-bars);}","map":{"version":3,"names":["AudioRecorder","constructor","mediaRecorder","audioContext","stream","chunks","isRecording","init","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","echoCancellation","noiseSuppression","error","console","Error","startRecording","onDataAvailable","timeSlice","arguments","length","undefined","MediaRecorder","mimeType","ondataavailable","event","data","size","push","start","stopRecording","Promise","resolve","reject","onstop","blob","Blob","type","stop","getAudioLevel","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","Math","min","startAudioLevelMonitoring","callback","interval","intervalId","setInterval","level","convertToWav","cleanup","getTracks","forEach","track","close","visualizeAudioLevel","bars","floor","repeat"],"sources":["/home/hugorteixeira/AvisoVC/frontend/src/utils/audioRecorder.js"],"sourcesContent":["/**\n * Audio Recorder Utility\n * Handles microphone access, recording, and audio chunk processing\n */\n\nexport class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n\n  /**\n   * Initialize and request microphone access\n   * @returns {Promise<MediaStream>}\n   */\n  async init() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          channelCount: 1,\n          sampleRate: 16000,\n          echoCancellation: true,\n          noiseSuppression: true,\n        },\n      });\n      return this.stream;\n    } catch (error) {\n      console.error('Failed to access microphone:', error);\n      throw new Error('Não foi possível acessar o microfone. Verifique as permissões.');\n    }\n  }\n\n  /**\n   * Start recording\n   * @param {Function} onDataAvailable - Callback when audio chunk is ready\n   * @param {number} timeSlice - Time between chunks in milliseconds (default: 1000ms)\n   */\n  startRecording(onDataAvailable, timeSlice = 1000) {\n    if (!this.stream) {\n      throw new Error('Microphone not initialized. Call init() first.');\n    }\n\n    this.chunks = [];\n    this.mediaRecorder = new MediaRecorder(this.stream, {\n      mimeType: 'audio/webm;codecs=opus',\n    });\n\n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        this.chunks.push(event.data);\n        if (onDataAvailable) {\n          onDataAvailable(event.data);\n        }\n      }\n    };\n\n    this.mediaRecorder.start(timeSlice);\n    this.isRecording = true;\n  }\n\n  /**\n   * Stop recording and return the complete audio blob\n   * @returns {Promise<Blob>}\n   */\n  stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder || !this.isRecording) {\n        reject(new Error('No active recording'));\n        return;\n      }\n\n      this.mediaRecorder.onstop = () => {\n        const blob = new Blob(this.chunks, { type: 'audio/webm;codecs=opus' });\n        this.isRecording = false;\n        resolve(blob);\n      };\n\n      this.mediaRecorder.stop();\n    });\n  }\n\n  /**\n   * Get audio level for visualization\n   * @returns {Promise<number>} Volume level (0-100)\n   */\n  async getAudioLevel() {\n    if (!this.stream) {\n      return 0;\n    }\n\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average volume\n    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n    return Math.min(100, (average / 128) * 100);\n  }\n\n  /**\n   * Start continuous audio level monitoring\n   * @param {Function} callback - Called with audio level (0-100)\n   * @param {number} interval - Update interval in milliseconds\n   * @returns {number} Interval ID for clearing\n   */\n  startAudioLevelMonitoring(callback, interval = 100) {\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n\n    const intervalId = setInterval(() => {\n      analyser.getByteFrequencyData(dataArray);\n      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n      const level = Math.min(100, (average / 128) * 100);\n      callback(level);\n    }, interval);\n\n    return intervalId;\n  }\n\n  /**\n   * Convert audio blob to WAV format\n   * @param {Blob} blob - Input audio blob\n   * @returns {Promise<Blob>} WAV formatted blob\n   */\n  async convertToWav(blob) {\n    // For simplicity, we'll send the webm directly to backend\n    // The backend can handle webm format\n    // If you need true WAV conversion, you'd need to decode and re-encode\n    return blob;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.mediaRecorder && this.isRecording) {\n      this.mediaRecorder.stop();\n    }\n\n    if (this.stream) {\n      this.stream.getTracks().forEach((track) => track.stop());\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n    }\n\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n}\n\n/**\n * Simple audio level visualization\n * @param {number} level - Audio level (0-100)\n * @returns {string} Visual representation\n */\nexport function visualizeAudioLevel(level) {\n  const bars = Math.floor(level / 10);\n  return '█'.repeat(bars) + '░'.repeat(10 - bars);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}