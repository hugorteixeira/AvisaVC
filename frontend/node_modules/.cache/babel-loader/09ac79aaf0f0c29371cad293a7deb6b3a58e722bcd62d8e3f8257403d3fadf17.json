{"ast":null,"code":"/**\n * Face Detection Utility using MediaPipe\n * Detects facial asymmetry that may indicate stroke\n */\n\n// Landmark indices\nconst LANDMARKS = {\n  MOUTH_LEFT: 61,\n  MOUTH_RIGHT: 291,\n  EYE_LEFT_OUTER: 33,\n  EYE_RIGHT_OUTER: 263\n};\n\n// Detection parameters\nconst BASELINE_FRAMES = 60; // Frames to collect for baseline\nconst RECENT_FRAMES = 10; // Recent frames to compare\nconst PERSIST_FRAMES = 8; // Frames to persist before alerting\n\nexport class FaceDetector {\n  constructor() {\n    this.faceLandmarker = null;\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Initialize MediaPipe Face Landmarker\n   * @returns {Promise<void>}\n   */\n  async init() {\n    try {\n      // Load MediaPipe vision tasks\n      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');\n      const {\n        FaceLandmarker,\n        FilesetResolver\n      } = vision;\n\n      // Initialize fileset\n      const filesetResolver = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');\n\n      // Create Face Landmarker\n      this.faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: 'GPU'\n        },\n        runningMode: 'VIDEO',\n        numFaces: 1\n      });\n    } catch (error) {\n      console.error('Failed to initialize FaceLandmarker:', error);\n      throw new Error('Não foi possível inicializar o detector facial. Verifique sua conexão.');\n    }\n  }\n\n  /**\n   * Process a video frame and detect facial asymmetry\n   * @param {HTMLVideoElement} video - Video element\n   * @param {number} timestamp - Performance timestamp\n   * @returns {Object} Detection result\n   */\n  detectFrame(video, timestamp) {\n    if (!this.faceLandmarker) {\n      throw new Error('Face landmarker not initialized');\n    }\n    const result = this.faceLandmarker.detectForVideo(video, timestamp);\n\n    // No face detected\n    if (!result || !result.faceLandmarks || result.faceLandmarks.length === 0) {\n      return {\n        faceDetected: false,\n        status: 'no_face',\n        message: 'Nenhum rosto detectado'\n      };\n    }\n    const landmarks = result.faceLandmarks[0];\n\n    // Get key landmarks\n    const eyeLeft = landmarks[LANDMARKS.EYE_LEFT_OUTER];\n    const eyeRight = landmarks[LANDMARKS.EYE_RIGHT_OUTER];\n    const mouthLeft = landmarks[LANDMARKS.MOUTH_LEFT];\n    const mouthRight = landmarks[LANDMARKS.MOUTH_RIGHT];\n\n    // Calculate asymmetry score\n    const skewScore = this.calculateAsymmetry(eyeLeft, eyeRight, mouthLeft, mouthRight);\n\n    // Update baseline or recent\n    if (!this.isCalibrated) {\n      this.baseline.push(skewScore);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n      if (this.baseline.length === BASELINE_FRAMES) {\n        this.isCalibrated = true;\n      }\n      return {\n        faceDetected: true,\n        status: 'calibrating',\n        message: `Calibrando... ${this.baseline.length}/${BASELINE_FRAMES}`,\n        progress: this.baseline.length / BASELINE_FRAMES * 100,\n        skewScore,\n        landmarks: {\n          eyeLeft,\n          eyeRight,\n          mouthLeft,\n          mouthRight\n        }\n      };\n    }\n\n    // Update recent frames\n    this.recent.push(skewScore);\n    if (this.recent.length > RECENT_FRAMES) {\n      this.recent.shift();\n    }\n\n    // Calculate statistics\n    const baselineMean = this.mean(this.baseline);\n    const baselineStd = this.std(this.baseline, baselineMean);\n    const recentMean = this.mean(this.recent);\n    const delta = Math.abs(recentMean - baselineMean);\n    const threshold = Math.max(0.07, 3 * baselineStd);\n\n    // Update persistence\n    if (this.recent.length === RECENT_FRAMES && delta > threshold) {\n      this.persist += 1;\n    } else {\n      this.persist = Math.max(0, this.persist - 1);\n    }\n\n    // Check for alert\n    if (this.persist >= PERSIST_FRAMES) {\n      this.isAlerted = true;\n    }\n\n    // Adaptive baseline update (only if not alerted and stable)\n    if (!this.isAlerted && this.recent.length === RECENT_FRAMES && delta < threshold / 2) {\n      this.baseline.push(recentMean);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n    }\n    return {\n      faceDetected: true,\n      status: this.isAlerted ? 'alert' : 'ok',\n      message: this.isAlerted ? 'ASSIMETRIA DETECTADA!' : 'Normal',\n      skewScore: recentMean,\n      baseline: baselineMean,\n      delta,\n      threshold,\n      persist: this.persist,\n      landmarks: {\n        eyeLeft,\n        eyeRight,\n        mouthLeft,\n        mouthRight\n      }\n    };\n  }\n\n  /**\n   * Calculate facial asymmetry score\n   * @param {Object} eyeL - Left eye landmark\n   * @param {Object} eyeR - Right eye landmark\n   * @param {Object} mouthL - Left mouth corner landmark\n   * @param {Object} mouthR - Right mouth corner landmark\n   * @returns {number} Asymmetry score\n   */\n  calculateAsymmetry(eyeL, eyeR, mouthL, mouthR) {\n    // Vector from right eye to left eye\n    const eyeVec = {\n      x: eyeL.x - eyeR.x,\n      y: eyeL.y - eyeR.y\n    };\n    const eyeAngle = Math.atan2(eyeVec.y, eyeVec.x);\n    const eyeDist = Math.hypot(eyeVec.x, eyeVec.y) || 1;\n\n    // Mouth vector\n    const mouthVec = {\n      x: mouthR.x - mouthL.x,\n      y: mouthR.y - mouthL.y\n    };\n\n    // Rotate mouth vector to align with eye axis\n    const cos = Math.cos(-eyeAngle);\n    const sin = Math.sin(-eyeAngle);\n    const mouthVyAligned = mouthVec.x * sin + mouthVec.y * cos;\n\n    // Normalized skew score\n    return mouthVyAligned / eyeDist;\n  }\n\n  /**\n   * Get baseline data for saving\n   * @returns {Object} Baseline data\n   */\n  getBaselineData() {\n    if (!this.isCalibrated) {\n      throw new Error('Calibration not complete');\n    }\n    return {\n      baseline: [...this.baseline],\n      mean: this.mean(this.baseline),\n      std: this.std(this.baseline, this.mean(this.baseline)),\n      frames: BASELINE_FRAMES,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Load baseline data\n   * @param {Object} data - Baseline data\n   */\n  loadBaseline(data) {\n    this.baseline = [...data.baseline];\n    this.isCalibrated = true;\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n  }\n\n  /**\n   * Reset detection state\n   */\n  reset() {\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.faceLandmarker) {\n      this.faceLandmarker.close();\n      this.faceLandmarker = null;\n    }\n  }\n\n  /**\n   * Calculate mean of array\n   * @param {number[]} arr\n   * @returns {number}\n   */\n  mean(arr) {\n    if (arr.length === 0) return 0;\n    return arr.reduce((a, b) => a + b, 0) / arr.length;\n  }\n\n  /**\n   * Calculate standard deviation\n   * @param {number[]} arr\n   * @param {number} mean\n   * @returns {number}\n   */\n  std(arr, mean) {\n    if (arr.length === 0) return 0;\n    const variance = arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;\n    return Math.sqrt(variance);\n  }\n}\n\n/**\n * Draw facial landmarks on canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} landmarks\n * @param {number} canvasWidth\n * @param {number} canvasHeight\n * @param {boolean} isAlert\n */\nexport function drawLandmarks(ctx, landmarks, canvasWidth, canvasHeight, isAlert = false) {\n  const {\n    eyeLeft,\n    eyeRight,\n    mouthLeft,\n    mouthRight\n  } = landmarks;\n\n  // Convert normalized coordinates to pixel coordinates\n  const toPx = point => ({\n    x: point.x * canvasWidth,\n    y: point.y * canvasHeight\n  });\n  const eyeL = toPx(eyeLeft);\n  const eyeR = toPx(eyeRight);\n  const mouthL = toPx(mouthLeft);\n  const mouthR = toPx(mouthRight);\n\n  // Draw eye line (reference)\n  ctx.strokeStyle = 'rgba(160, 160, 160, 0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(eyeL.x, eyeL.y);\n  ctx.lineTo(eyeR.x, eyeR.y);\n  ctx.stroke();\n\n  // Draw mouth line (indicator)\n  ctx.strokeStyle = isAlert ? 'rgba(255, 70, 70, 0.9)' : 'rgba(60, 220, 120, 0.9)';\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(mouthL.x, mouthL.y);\n  ctx.lineTo(mouthR.x, mouthR.y);\n  ctx.stroke();\n}","map":{"version":3,"names":["LANDMARKS","MOUTH_LEFT","MOUTH_RIGHT","EYE_LEFT_OUTER","EYE_RIGHT_OUTER","BASELINE_FRAMES","RECENT_FRAMES","PERSIST_FRAMES","FaceDetector","constructor","faceLandmarker","baseline","recent","persist","isAlerted","isCalibrated","init","vision","FaceLandmarker","FilesetResolver","filesetResolver","forVisionTasks","createFromOptions","baseOptions","modelAssetPath","delegate","runningMode","numFaces","error","console","Error","detectFrame","video","timestamp","result","detectForVideo","faceLandmarks","length","faceDetected","status","message","landmarks","eyeLeft","eyeRight","mouthLeft","mouthRight","skewScore","calculateAsymmetry","push","shift","progress","baselineMean","mean","baselineStd","std","recentMean","delta","Math","abs","threshold","max","eyeL","eyeR","mouthL","mouthR","eyeVec","x","y","eyeAngle","atan2","eyeDist","hypot","mouthVec","cos","sin","mouthVyAligned","getBaselineData","frames","Date","now","loadBaseline","data","reset","cleanup","close","arr","reduce","a","b","variance","sum","val","sqrt","drawLandmarks","ctx","canvasWidth","canvasHeight","isAlert","toPx","point","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke"],"sources":["/home/hugorteixeira/AvisoVC/frontend/src/utils/faceDetection.js"],"sourcesContent":["/**\n * Face Detection Utility using MediaPipe\n * Detects facial asymmetry that may indicate stroke\n */\n\n// Landmark indices\nconst LANDMARKS = {\n  MOUTH_LEFT: 61,\n  MOUTH_RIGHT: 291,\n  EYE_LEFT_OUTER: 33,\n  EYE_RIGHT_OUTER: 263,\n};\n\n// Detection parameters\nconst BASELINE_FRAMES = 60; // Frames to collect for baseline\nconst RECENT_FRAMES = 10; // Recent frames to compare\nconst PERSIST_FRAMES = 8; // Frames to persist before alerting\n\nexport class FaceDetector {\n  constructor() {\n    this.faceLandmarker = null;\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Initialize MediaPipe Face Landmarker\n   * @returns {Promise<void>}\n   */\n  async init() {\n    try {\n      // Load MediaPipe vision tasks\n      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');\n      const { FaceLandmarker, FilesetResolver } = vision;\n\n      // Initialize fileset\n      const filesetResolver = await FilesetResolver.forVisionTasks(\n        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'\n      );\n\n      // Create Face Landmarker\n      this.faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath:\n            'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: 'GPU',\n        },\n        runningMode: 'VIDEO',\n        numFaces: 1,\n      });\n    } catch (error) {\n      console.error('Failed to initialize FaceLandmarker:', error);\n      throw new Error('Não foi possível inicializar o detector facial. Verifique sua conexão.');\n    }\n  }\n\n  /**\n   * Process a video frame and detect facial asymmetry\n   * @param {HTMLVideoElement} video - Video element\n   * @param {number} timestamp - Performance timestamp\n   * @returns {Object} Detection result\n   */\n  detectFrame(video, timestamp) {\n    if (!this.faceLandmarker) {\n      throw new Error('Face landmarker not initialized');\n    }\n\n    const result = this.faceLandmarker.detectForVideo(video, timestamp);\n\n    // No face detected\n    if (!result || !result.faceLandmarks || result.faceLandmarks.length === 0) {\n      return {\n        faceDetected: false,\n        status: 'no_face',\n        message: 'Nenhum rosto detectado',\n      };\n    }\n\n    const landmarks = result.faceLandmarks[0];\n\n    // Get key landmarks\n    const eyeLeft = landmarks[LANDMARKS.EYE_LEFT_OUTER];\n    const eyeRight = landmarks[LANDMARKS.EYE_RIGHT_OUTER];\n    const mouthLeft = landmarks[LANDMARKS.MOUTH_LEFT];\n    const mouthRight = landmarks[LANDMARKS.MOUTH_RIGHT];\n\n    // Calculate asymmetry score\n    const skewScore = this.calculateAsymmetry(eyeLeft, eyeRight, mouthLeft, mouthRight);\n\n    // Update baseline or recent\n    if (!this.isCalibrated) {\n      this.baseline.push(skewScore);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n\n      if (this.baseline.length === BASELINE_FRAMES) {\n        this.isCalibrated = true;\n      }\n\n      return {\n        faceDetected: true,\n        status: 'calibrating',\n        message: `Calibrando... ${this.baseline.length}/${BASELINE_FRAMES}`,\n        progress: (this.baseline.length / BASELINE_FRAMES) * 100,\n        skewScore,\n        landmarks: { eyeLeft, eyeRight, mouthLeft, mouthRight },\n      };\n    }\n\n    // Update recent frames\n    this.recent.push(skewScore);\n    if (this.recent.length > RECENT_FRAMES) {\n      this.recent.shift();\n    }\n\n    // Calculate statistics\n    const baselineMean = this.mean(this.baseline);\n    const baselineStd = this.std(this.baseline, baselineMean);\n    const recentMean = this.mean(this.recent);\n    const delta = Math.abs(recentMean - baselineMean);\n    const threshold = Math.max(0.07, 3 * baselineStd);\n\n    // Update persistence\n    if (this.recent.length === RECENT_FRAMES && delta > threshold) {\n      this.persist += 1;\n    } else {\n      this.persist = Math.max(0, this.persist - 1);\n    }\n\n    // Check for alert\n    if (this.persist >= PERSIST_FRAMES) {\n      this.isAlerted = true;\n    }\n\n    // Adaptive baseline update (only if not alerted and stable)\n    if (!this.isAlerted && this.recent.length === RECENT_FRAMES && delta < threshold / 2) {\n      this.baseline.push(recentMean);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n    }\n\n    return {\n      faceDetected: true,\n      status: this.isAlerted ? 'alert' : 'ok',\n      message: this.isAlerted ? 'ASSIMETRIA DETECTADA!' : 'Normal',\n      skewScore: recentMean,\n      baseline: baselineMean,\n      delta,\n      threshold,\n      persist: this.persist,\n      landmarks: { eyeLeft, eyeRight, mouthLeft, mouthRight },\n    };\n  }\n\n  /**\n   * Calculate facial asymmetry score\n   * @param {Object} eyeL - Left eye landmark\n   * @param {Object} eyeR - Right eye landmark\n   * @param {Object} mouthL - Left mouth corner landmark\n   * @param {Object} mouthR - Right mouth corner landmark\n   * @returns {number} Asymmetry score\n   */\n  calculateAsymmetry(eyeL, eyeR, mouthL, mouthR) {\n    // Vector from right eye to left eye\n    const eyeVec = {\n      x: eyeL.x - eyeR.x,\n      y: eyeL.y - eyeR.y,\n    };\n    const eyeAngle = Math.atan2(eyeVec.y, eyeVec.x);\n    const eyeDist = Math.hypot(eyeVec.x, eyeVec.y) || 1;\n\n    // Mouth vector\n    const mouthVec = {\n      x: mouthR.x - mouthL.x,\n      y: mouthR.y - mouthL.y,\n    };\n\n    // Rotate mouth vector to align with eye axis\n    const cos = Math.cos(-eyeAngle);\n    const sin = Math.sin(-eyeAngle);\n    const mouthVyAligned = mouthVec.x * sin + mouthVec.y * cos;\n\n    // Normalized skew score\n    return mouthVyAligned / eyeDist;\n  }\n\n  /**\n   * Get baseline data for saving\n   * @returns {Object} Baseline data\n   */\n  getBaselineData() {\n    if (!this.isCalibrated) {\n      throw new Error('Calibration not complete');\n    }\n\n    return {\n      baseline: [...this.baseline],\n      mean: this.mean(this.baseline),\n      std: this.std(this.baseline, this.mean(this.baseline)),\n      frames: BASELINE_FRAMES,\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Load baseline data\n   * @param {Object} data - Baseline data\n   */\n  loadBaseline(data) {\n    this.baseline = [...data.baseline];\n    this.isCalibrated = true;\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n  }\n\n  /**\n   * Reset detection state\n   */\n  reset() {\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.faceLandmarker) {\n      this.faceLandmarker.close();\n      this.faceLandmarker = null;\n    }\n  }\n\n  /**\n   * Calculate mean of array\n   * @param {number[]} arr\n   * @returns {number}\n   */\n  mean(arr) {\n    if (arr.length === 0) return 0;\n    return arr.reduce((a, b) => a + b, 0) / arr.length;\n  }\n\n  /**\n   * Calculate standard deviation\n   * @param {number[]} arr\n   * @param {number} mean\n   * @returns {number}\n   */\n  std(arr, mean) {\n    if (arr.length === 0) return 0;\n    const variance = arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;\n    return Math.sqrt(variance);\n  }\n}\n\n/**\n * Draw facial landmarks on canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} landmarks\n * @param {number} canvasWidth\n * @param {number} canvasHeight\n * @param {boolean} isAlert\n */\nexport function drawLandmarks(ctx, landmarks, canvasWidth, canvasHeight, isAlert = false) {\n  const { eyeLeft, eyeRight, mouthLeft, mouthRight } = landmarks;\n\n  // Convert normalized coordinates to pixel coordinates\n  const toPx = (point) => ({\n    x: point.x * canvasWidth,\n    y: point.y * canvasHeight,\n  });\n\n  const eyeL = toPx(eyeLeft);\n  const eyeR = toPx(eyeRight);\n  const mouthL = toPx(mouthLeft);\n  const mouthR = toPx(mouthRight);\n\n  // Draw eye line (reference)\n  ctx.strokeStyle = 'rgba(160, 160, 160, 0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(eyeL.x, eyeL.y);\n  ctx.lineTo(eyeR.x, eyeR.y);\n  ctx.stroke();\n\n  // Draw mouth line (indicator)\n  ctx.strokeStyle = isAlert ? 'rgba(255, 70, 70, 0.9)' : 'rgba(60, 220, 120, 0.9)';\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(mouthL.x, mouthL.y);\n  ctx.lineTo(mouthR.x, mouthR.y);\n  ctx.stroke();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}