{"ast":null,"code":"/**\n * Face Detection Utility using MediaPipe\n * Detects facial asymmetry that may indicate stroke\n */// Landmark indices\nconst LANDMARKS={MOUTH_LEFT:61,MOUTH_RIGHT:291,EYE_LEFT_OUTER:33,EYE_RIGHT_OUTER:263};// Detection parameters\nconst BASELINE_FRAMES=60;// Frames to collect for baseline\nconst RECENT_FRAMES=10;// Recent frames to compare\nconst PERSIST_FRAMES=8;// Frames to persist before alerting\nexport class FaceDetector{constructor(){this.faceLandmarker=null;this.baseline=[];this.recent=[];this.persist=0;this.isAlerted=false;this.isCalibrated=false;}/**\n   * Initialize MediaPipe Face Landmarker\n   * @returns {Promise<void>}\n   */async init(){try{// Load MediaPipe vision tasks\nconst vision=await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');const{FaceLandmarker,FilesetResolver}=vision;// Initialize fileset\nconst filesetResolver=await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');// Create Face Landmarker\nthis.faceLandmarker=await FaceLandmarker.createFromOptions(filesetResolver,{baseOptions:{modelAssetPath:'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',delegate:'GPU'},runningMode:'VIDEO',numFaces:1});}catch(error){console.error('Failed to initialize FaceLandmarker:',error);throw new Error('Não foi possível inicializar o detector facial. Verifique sua conexão.');}}/**\n   * Process a video frame and detect facial asymmetry\n   * @param {HTMLVideoElement} video - Video element\n   * @param {number} timestamp - Performance timestamp\n   * @returns {Object} Detection result\n   */detectFrame(video,timestamp){if(!this.faceLandmarker){throw new Error('Face landmarker not initialized');}const result=this.faceLandmarker.detectForVideo(video,timestamp);// No face detected\nif(!result||!result.faceLandmarks||result.faceLandmarks.length===0){return{faceDetected:false,status:'no_face',message:'Nenhum rosto detectado'};}const landmarks=result.faceLandmarks[0];// Get key landmarks\nconst eyeLeft=landmarks[LANDMARKS.EYE_LEFT_OUTER];const eyeRight=landmarks[LANDMARKS.EYE_RIGHT_OUTER];const mouthLeft=landmarks[LANDMARKS.MOUTH_LEFT];const mouthRight=landmarks[LANDMARKS.MOUTH_RIGHT];// Calculate asymmetry score\nconst skewScore=this.calculateAsymmetry(eyeLeft,eyeRight,mouthLeft,mouthRight);// Update baseline or recent\nif(!this.isCalibrated){this.baseline.push(skewScore);if(this.baseline.length>BASELINE_FRAMES){this.baseline.shift();}if(this.baseline.length===BASELINE_FRAMES){this.isCalibrated=true;}return{faceDetected:true,status:'calibrating',message:\"Calibrando... \".concat(this.baseline.length,\"/\").concat(BASELINE_FRAMES),progress:this.baseline.length/BASELINE_FRAMES*100,skewScore,landmarks:{eyeLeft,eyeRight,mouthLeft,mouthRight}};}// Update recent frames\nthis.recent.push(skewScore);if(this.recent.length>RECENT_FRAMES){this.recent.shift();}// Calculate statistics\nconst baselineMean=this.mean(this.baseline);const baselineStd=this.std(this.baseline,baselineMean);const recentMean=this.mean(this.recent);const delta=Math.abs(recentMean-baselineMean);const threshold=Math.max(0.07,3*baselineStd);// Update persistence\nif(this.recent.length===RECENT_FRAMES&&delta>threshold){this.persist+=1;}else{this.persist=Math.max(0,this.persist-1);}// Check for alert\nif(this.persist>=PERSIST_FRAMES){this.isAlerted=true;}// Adaptive baseline update (only if not alerted and stable)\nif(!this.isAlerted&&this.recent.length===RECENT_FRAMES&&delta<threshold/2){this.baseline.push(recentMean);if(this.baseline.length>BASELINE_FRAMES){this.baseline.shift();}}return{faceDetected:true,status:this.isAlerted?'alert':'ok',message:this.isAlerted?'ASSIMETRIA DETECTADA!':'Normal',skewScore:recentMean,baseline:baselineMean,delta,threshold,persist:this.persist,landmarks:{eyeLeft,eyeRight,mouthLeft,mouthRight}};}/**\n   * Calculate facial asymmetry score\n   * @param {Object} eyeL - Left eye landmark\n   * @param {Object} eyeR - Right eye landmark\n   * @param {Object} mouthL - Left mouth corner landmark\n   * @param {Object} mouthR - Right mouth corner landmark\n   * @returns {number} Asymmetry score\n   */calculateAsymmetry(eyeL,eyeR,mouthL,mouthR){// Vector from right eye to left eye\nconst eyeVec={x:eyeL.x-eyeR.x,y:eyeL.y-eyeR.y};const eyeAngle=Math.atan2(eyeVec.y,eyeVec.x);const eyeDist=Math.hypot(eyeVec.x,eyeVec.y)||1;// Mouth vector\nconst mouthVec={x:mouthR.x-mouthL.x,y:mouthR.y-mouthL.y};// Rotate mouth vector to align with eye axis\nconst cos=Math.cos(-eyeAngle);const sin=Math.sin(-eyeAngle);const mouthVyAligned=mouthVec.x*sin+mouthVec.y*cos;// Normalized skew score\nreturn mouthVyAligned/eyeDist;}/**\n   * Get baseline data for saving\n   * @returns {Object} Baseline data\n   */getBaselineData(){if(!this.isCalibrated){throw new Error('Calibration not complete');}return{baseline:[...this.baseline],mean:this.mean(this.baseline),std:this.std(this.baseline,this.mean(this.baseline)),frames:BASELINE_FRAMES,timestamp:Date.now()};}/**\n   * Load baseline data\n   * @param {Object} data - Baseline data\n   */loadBaseline(data){this.baseline=[...data.baseline];this.isCalibrated=true;this.recent=[];this.persist=0;this.isAlerted=false;}/**\n   * Reset detection state\n   */reset(){this.baseline=[];this.recent=[];this.persist=0;this.isAlerted=false;this.isCalibrated=false;}/**\n   * Clean up resources\n   */cleanup(){if(this.faceLandmarker){this.faceLandmarker.close();this.faceLandmarker=null;}}/**\n   * Calculate mean of array\n   * @param {number[]} arr\n   * @returns {number}\n   */mean(arr){if(arr.length===0)return 0;return arr.reduce((a,b)=>a+b,0)/arr.length;}/**\n   * Calculate standard deviation\n   * @param {number[]} arr\n   * @param {number} mean\n   * @returns {number}\n   */std(arr,mean){if(arr.length===0)return 0;const variance=arr.reduce((sum,val)=>sum+(val-mean)**2,0)/arr.length;return Math.sqrt(variance);}}/**\n * Draw facial landmarks on canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} landmarks\n * @param {number} canvasWidth\n * @param {number} canvasHeight\n * @param {boolean} isAlert\n */export function drawLandmarks(ctx,landmarks,canvasWidth,canvasHeight){let isAlert=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;const{eyeLeft,eyeRight,mouthLeft,mouthRight}=landmarks;// Convert normalized coordinates to pixel coordinates\nconst toPx=point=>({x:point.x*canvasWidth,y:point.y*canvasHeight});const eyeL=toPx(eyeLeft);const eyeR=toPx(eyeRight);const mouthL=toPx(mouthLeft);const mouthR=toPx(mouthRight);// Draw eye line (reference)\nctx.strokeStyle='rgba(160, 160, 160, 0.7)';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(eyeL.x,eyeL.y);ctx.lineTo(eyeR.x,eyeR.y);ctx.stroke();// Draw mouth line (indicator)\nctx.strokeStyle=isAlert?'rgba(255, 70, 70, 0.9)':'rgba(60, 220, 120, 0.9)';ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(mouthL.x,mouthL.y);ctx.lineTo(mouthR.x,mouthR.y);ctx.stroke();}","map":{"version":3,"names":["LANDMARKS","MOUTH_LEFT","MOUTH_RIGHT","EYE_LEFT_OUTER","EYE_RIGHT_OUTER","BASELINE_FRAMES","RECENT_FRAMES","PERSIST_FRAMES","FaceDetector","constructor","faceLandmarker","baseline","recent","persist","isAlerted","isCalibrated","init","vision","FaceLandmarker","FilesetResolver","filesetResolver","forVisionTasks","createFromOptions","baseOptions","modelAssetPath","delegate","runningMode","numFaces","error","console","Error","detectFrame","video","timestamp","result","detectForVideo","faceLandmarks","length","faceDetected","status","message","landmarks","eyeLeft","eyeRight","mouthLeft","mouthRight","skewScore","calculateAsymmetry","push","shift","concat","progress","baselineMean","mean","baselineStd","std","recentMean","delta","Math","abs","threshold","max","eyeL","eyeR","mouthL","mouthR","eyeVec","x","y","eyeAngle","atan2","eyeDist","hypot","mouthVec","cos","sin","mouthVyAligned","getBaselineData","frames","Date","now","loadBaseline","data","reset","cleanup","close","arr","reduce","a","b","variance","sum","val","sqrt","drawLandmarks","ctx","canvasWidth","canvasHeight","isAlert","arguments","undefined","toPx","point","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke"],"sources":["/home/hugorteixeira/AvisoVC/frontend/src/utils/faceDetection.js"],"sourcesContent":["/**\n * Face Detection Utility using MediaPipe\n * Detects facial asymmetry that may indicate stroke\n */\n\n// Landmark indices\nconst LANDMARKS = {\n  MOUTH_LEFT: 61,\n  MOUTH_RIGHT: 291,\n  EYE_LEFT_OUTER: 33,\n  EYE_RIGHT_OUTER: 263,\n};\n\n// Detection parameters\nconst BASELINE_FRAMES = 60; // Frames to collect for baseline\nconst RECENT_FRAMES = 10; // Recent frames to compare\nconst PERSIST_FRAMES = 8; // Frames to persist before alerting\n\nexport class FaceDetector {\n  constructor() {\n    this.faceLandmarker = null;\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Initialize MediaPipe Face Landmarker\n   * @returns {Promise<void>}\n   */\n  async init() {\n    try {\n      // Load MediaPipe vision tasks\n      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');\n      const { FaceLandmarker, FilesetResolver } = vision;\n\n      // Initialize fileset\n      const filesetResolver = await FilesetResolver.forVisionTasks(\n        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'\n      );\n\n      // Create Face Landmarker\n      this.faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath:\n            'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: 'GPU',\n        },\n        runningMode: 'VIDEO',\n        numFaces: 1,\n      });\n    } catch (error) {\n      console.error('Failed to initialize FaceLandmarker:', error);\n      throw new Error('Não foi possível inicializar o detector facial. Verifique sua conexão.');\n    }\n  }\n\n  /**\n   * Process a video frame and detect facial asymmetry\n   * @param {HTMLVideoElement} video - Video element\n   * @param {number} timestamp - Performance timestamp\n   * @returns {Object} Detection result\n   */\n  detectFrame(video, timestamp) {\n    if (!this.faceLandmarker) {\n      throw new Error('Face landmarker not initialized');\n    }\n\n    const result = this.faceLandmarker.detectForVideo(video, timestamp);\n\n    // No face detected\n    if (!result || !result.faceLandmarks || result.faceLandmarks.length === 0) {\n      return {\n        faceDetected: false,\n        status: 'no_face',\n        message: 'Nenhum rosto detectado',\n      };\n    }\n\n    const landmarks = result.faceLandmarks[0];\n\n    // Get key landmarks\n    const eyeLeft = landmarks[LANDMARKS.EYE_LEFT_OUTER];\n    const eyeRight = landmarks[LANDMARKS.EYE_RIGHT_OUTER];\n    const mouthLeft = landmarks[LANDMARKS.MOUTH_LEFT];\n    const mouthRight = landmarks[LANDMARKS.MOUTH_RIGHT];\n\n    // Calculate asymmetry score\n    const skewScore = this.calculateAsymmetry(eyeLeft, eyeRight, mouthLeft, mouthRight);\n\n    // Update baseline or recent\n    if (!this.isCalibrated) {\n      this.baseline.push(skewScore);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n\n      if (this.baseline.length === BASELINE_FRAMES) {\n        this.isCalibrated = true;\n      }\n\n      return {\n        faceDetected: true,\n        status: 'calibrating',\n        message: `Calibrando... ${this.baseline.length}/${BASELINE_FRAMES}`,\n        progress: (this.baseline.length / BASELINE_FRAMES) * 100,\n        skewScore,\n        landmarks: { eyeLeft, eyeRight, mouthLeft, mouthRight },\n      };\n    }\n\n    // Update recent frames\n    this.recent.push(skewScore);\n    if (this.recent.length > RECENT_FRAMES) {\n      this.recent.shift();\n    }\n\n    // Calculate statistics\n    const baselineMean = this.mean(this.baseline);\n    const baselineStd = this.std(this.baseline, baselineMean);\n    const recentMean = this.mean(this.recent);\n    const delta = Math.abs(recentMean - baselineMean);\n    const threshold = Math.max(0.07, 3 * baselineStd);\n\n    // Update persistence\n    if (this.recent.length === RECENT_FRAMES && delta > threshold) {\n      this.persist += 1;\n    } else {\n      this.persist = Math.max(0, this.persist - 1);\n    }\n\n    // Check for alert\n    if (this.persist >= PERSIST_FRAMES) {\n      this.isAlerted = true;\n    }\n\n    // Adaptive baseline update (only if not alerted and stable)\n    if (!this.isAlerted && this.recent.length === RECENT_FRAMES && delta < threshold / 2) {\n      this.baseline.push(recentMean);\n      if (this.baseline.length > BASELINE_FRAMES) {\n        this.baseline.shift();\n      }\n    }\n\n    return {\n      faceDetected: true,\n      status: this.isAlerted ? 'alert' : 'ok',\n      message: this.isAlerted ? 'ASSIMETRIA DETECTADA!' : 'Normal',\n      skewScore: recentMean,\n      baseline: baselineMean,\n      delta,\n      threshold,\n      persist: this.persist,\n      landmarks: { eyeLeft, eyeRight, mouthLeft, mouthRight },\n    };\n  }\n\n  /**\n   * Calculate facial asymmetry score\n   * @param {Object} eyeL - Left eye landmark\n   * @param {Object} eyeR - Right eye landmark\n   * @param {Object} mouthL - Left mouth corner landmark\n   * @param {Object} mouthR - Right mouth corner landmark\n   * @returns {number} Asymmetry score\n   */\n  calculateAsymmetry(eyeL, eyeR, mouthL, mouthR) {\n    // Vector from right eye to left eye\n    const eyeVec = {\n      x: eyeL.x - eyeR.x,\n      y: eyeL.y - eyeR.y,\n    };\n    const eyeAngle = Math.atan2(eyeVec.y, eyeVec.x);\n    const eyeDist = Math.hypot(eyeVec.x, eyeVec.y) || 1;\n\n    // Mouth vector\n    const mouthVec = {\n      x: mouthR.x - mouthL.x,\n      y: mouthR.y - mouthL.y,\n    };\n\n    // Rotate mouth vector to align with eye axis\n    const cos = Math.cos(-eyeAngle);\n    const sin = Math.sin(-eyeAngle);\n    const mouthVyAligned = mouthVec.x * sin + mouthVec.y * cos;\n\n    // Normalized skew score\n    return mouthVyAligned / eyeDist;\n  }\n\n  /**\n   * Get baseline data for saving\n   * @returns {Object} Baseline data\n   */\n  getBaselineData() {\n    if (!this.isCalibrated) {\n      throw new Error('Calibration not complete');\n    }\n\n    return {\n      baseline: [...this.baseline],\n      mean: this.mean(this.baseline),\n      std: this.std(this.baseline, this.mean(this.baseline)),\n      frames: BASELINE_FRAMES,\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Load baseline data\n   * @param {Object} data - Baseline data\n   */\n  loadBaseline(data) {\n    this.baseline = [...data.baseline];\n    this.isCalibrated = true;\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n  }\n\n  /**\n   * Reset detection state\n   */\n  reset() {\n    this.baseline = [];\n    this.recent = [];\n    this.persist = 0;\n    this.isAlerted = false;\n    this.isCalibrated = false;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.faceLandmarker) {\n      this.faceLandmarker.close();\n      this.faceLandmarker = null;\n    }\n  }\n\n  /**\n   * Calculate mean of array\n   * @param {number[]} arr\n   * @returns {number}\n   */\n  mean(arr) {\n    if (arr.length === 0) return 0;\n    return arr.reduce((a, b) => a + b, 0) / arr.length;\n  }\n\n  /**\n   * Calculate standard deviation\n   * @param {number[]} arr\n   * @param {number} mean\n   * @returns {number}\n   */\n  std(arr, mean) {\n    if (arr.length === 0) return 0;\n    const variance = arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;\n    return Math.sqrt(variance);\n  }\n}\n\n/**\n * Draw facial landmarks on canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} landmarks\n * @param {number} canvasWidth\n * @param {number} canvasHeight\n * @param {boolean} isAlert\n */\nexport function drawLandmarks(ctx, landmarks, canvasWidth, canvasHeight, isAlert = false) {\n  const { eyeLeft, eyeRight, mouthLeft, mouthRight } = landmarks;\n\n  // Convert normalized coordinates to pixel coordinates\n  const toPx = (point) => ({\n    x: point.x * canvasWidth,\n    y: point.y * canvasHeight,\n  });\n\n  const eyeL = toPx(eyeLeft);\n  const eyeR = toPx(eyeRight);\n  const mouthL = toPx(mouthLeft);\n  const mouthR = toPx(mouthRight);\n\n  // Draw eye line (reference)\n  ctx.strokeStyle = 'rgba(160, 160, 160, 0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(eyeL.x, eyeL.y);\n  ctx.lineTo(eyeR.x, eyeR.y);\n  ctx.stroke();\n\n  // Draw mouth line (indicator)\n  ctx.strokeStyle = isAlert ? 'rgba(255, 70, 70, 0.9)' : 'rgba(60, 220, 120, 0.9)';\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(mouthL.x, mouthL.y);\n  ctx.lineTo(mouthR.x, mouthR.y);\n  ctx.stroke();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}