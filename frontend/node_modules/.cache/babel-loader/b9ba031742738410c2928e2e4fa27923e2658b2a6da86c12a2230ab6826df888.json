{"ast":null,"code":"/**\n * Audio Recorder Utility\n * Handles microphone access, recording, and audio chunk processing\n */\n\nexport class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n\n  /**\n   * Initialize and request microphone access\n   * @returns {Promise<MediaStream>}\n   */\n  async init() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          channelCount: 1,\n          sampleRate: 16000,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n      return this.stream;\n    } catch (error) {\n      console.error('Failed to access microphone:', error);\n      throw new Error('Não foi possível acessar o microfone. Verifique as permissões.');\n    }\n  }\n\n  /**\n   * Start recording\n   * @param {Function} onDataAvailable - Callback when audio chunk is ready\n   * @param {number} timeSlice - Time between chunks in milliseconds (default: 1000ms)\n   */\n  startRecording(onDataAvailable, timeSlice = 1000) {\n    if (!this.stream) {\n      throw new Error('Microphone not initialized. Call init() first.');\n    }\n    this.chunks = [];\n    this.mediaRecorder = new MediaRecorder(this.stream, {\n      mimeType: 'audio/webm;codecs=opus'\n    });\n    this.mediaRecorder.ondataavailable = event => {\n      if (event.data.size > 0) {\n        this.chunks.push(event.data);\n        if (onDataAvailable) {\n          onDataAvailable(event.data);\n        }\n      }\n    };\n    this.mediaRecorder.start(timeSlice);\n    this.isRecording = true;\n  }\n\n  /**\n   * Stop recording and return the complete audio blob\n   * @returns {Promise<Blob>}\n   */\n  stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder || !this.isRecording) {\n        reject(new Error('No active recording'));\n        return;\n      }\n      this.mediaRecorder.onstop = () => {\n        const blob = new Blob(this.chunks, {\n          type: 'audio/webm;codecs=opus'\n        });\n        this.isRecording = false;\n        resolve(blob);\n      };\n      this.mediaRecorder.stop();\n    });\n  }\n\n  /**\n   * Get audio level for visualization\n   * @returns {Promise<number>} Volume level (0-100)\n   */\n  async getAudioLevel() {\n    if (!this.stream) {\n      return 0;\n    }\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average volume\n    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n    return Math.min(100, average / 128 * 100);\n  }\n\n  /**\n   * Start continuous audio level monitoring\n   * @param {Function} callback - Called with audio level (0-100)\n   * @param {number} interval - Update interval in milliseconds\n   * @returns {number} Interval ID for clearing\n   */\n  startAudioLevelMonitoring(callback, interval = 100) {\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    const intervalId = setInterval(() => {\n      analyser.getByteFrequencyData(dataArray);\n      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n      const level = Math.min(100, average / 128 * 100);\n      callback(level);\n    }, interval);\n    return intervalId;\n  }\n\n  /**\n   * Convert audio blob to WAV format\n   * @param {Blob} blob - Input audio blob\n   * @returns {Promise<Blob>} WAV formatted blob\n   */\n  async convertToWav(blob) {\n    // For simplicity, we'll send the webm directly to backend\n    // The backend can handle webm format\n    // If you need true WAV conversion, you'd need to decode and re-encode\n    return blob;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.mediaRecorder && this.isRecording) {\n      this.mediaRecorder.stop();\n    }\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n    }\n    if (this.audioContext) {\n      this.audioContext.close();\n    }\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n}\n\n/**\n * Simple audio level visualization\n * @param {number} level - Audio level (0-100)\n * @returns {string} Visual representation\n */\nexport function visualizeAudioLevel(level) {\n  const bars = Math.floor(level / 10);\n  return '█'.repeat(bars) + '░'.repeat(10 - bars);\n}","map":{"version":3,"names":["AudioRecorder","constructor","mediaRecorder","audioContext","stream","chunks","isRecording","init","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","echoCancellation","noiseSuppression","error","console","Error","startRecording","onDataAvailable","timeSlice","MediaRecorder","mimeType","ondataavailable","event","data","size","push","start","stopRecording","Promise","resolve","reject","onstop","blob","Blob","type","stop","getAudioLevel","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","length","Math","min","startAudioLevelMonitoring","callback","interval","intervalId","setInterval","level","convertToWav","cleanup","getTracks","forEach","track","close","visualizeAudioLevel","bars","floor","repeat"],"sources":["/home/hugorteixeira/AvisoVC/frontend/src/utils/audioRecorder.js"],"sourcesContent":["/**\n * Audio Recorder Utility\n * Handles microphone access, recording, and audio chunk processing\n */\n\nexport class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n\n  /**\n   * Initialize and request microphone access\n   * @returns {Promise<MediaStream>}\n   */\n  async init() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          channelCount: 1,\n          sampleRate: 16000,\n          echoCancellation: true,\n          noiseSuppression: true,\n        },\n      });\n      return this.stream;\n    } catch (error) {\n      console.error('Failed to access microphone:', error);\n      throw new Error('Não foi possível acessar o microfone. Verifique as permissões.');\n    }\n  }\n\n  /**\n   * Start recording\n   * @param {Function} onDataAvailable - Callback when audio chunk is ready\n   * @param {number} timeSlice - Time between chunks in milliseconds (default: 1000ms)\n   */\n  startRecording(onDataAvailable, timeSlice = 1000) {\n    if (!this.stream) {\n      throw new Error('Microphone not initialized. Call init() first.');\n    }\n\n    this.chunks = [];\n    this.mediaRecorder = new MediaRecorder(this.stream, {\n      mimeType: 'audio/webm;codecs=opus',\n    });\n\n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        this.chunks.push(event.data);\n        if (onDataAvailable) {\n          onDataAvailable(event.data);\n        }\n      }\n    };\n\n    this.mediaRecorder.start(timeSlice);\n    this.isRecording = true;\n  }\n\n  /**\n   * Stop recording and return the complete audio blob\n   * @returns {Promise<Blob>}\n   */\n  stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder || !this.isRecording) {\n        reject(new Error('No active recording'));\n        return;\n      }\n\n      this.mediaRecorder.onstop = () => {\n        const blob = new Blob(this.chunks, { type: 'audio/webm;codecs=opus' });\n        this.isRecording = false;\n        resolve(blob);\n      };\n\n      this.mediaRecorder.stop();\n    });\n  }\n\n  /**\n   * Get audio level for visualization\n   * @returns {Promise<number>} Volume level (0-100)\n   */\n  async getAudioLevel() {\n    if (!this.stream) {\n      return 0;\n    }\n\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average volume\n    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n    return Math.min(100, (average / 128) * 100);\n  }\n\n  /**\n   * Start continuous audio level monitoring\n   * @param {Function} callback - Called with audio level (0-100)\n   * @param {number} interval - Update interval in milliseconds\n   * @returns {number} Interval ID for clearing\n   */\n  startAudioLevelMonitoring(callback, interval = 100) {\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    const source = this.audioContext.createMediaStreamSource(this.stream);\n    const analyser = this.audioContext.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n\n    const intervalId = setInterval(() => {\n      analyser.getByteFrequencyData(dataArray);\n      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;\n      const level = Math.min(100, (average / 128) * 100);\n      callback(level);\n    }, interval);\n\n    return intervalId;\n  }\n\n  /**\n   * Convert audio blob to WAV format\n   * @param {Blob} blob - Input audio blob\n   * @returns {Promise<Blob>} WAV formatted blob\n   */\n  async convertToWav(blob) {\n    // For simplicity, we'll send the webm directly to backend\n    // The backend can handle webm format\n    // If you need true WAV conversion, you'd need to decode and re-encode\n    return blob;\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.mediaRecorder && this.isRecording) {\n      this.mediaRecorder.stop();\n    }\n\n    if (this.stream) {\n      this.stream.getTracks().forEach((track) => track.stop());\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n    }\n\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.stream = null;\n    this.chunks = [];\n    this.isRecording = false;\n  }\n}\n\n/**\n * Simple audio level visualization\n * @param {number} level - Audio level (0-100)\n * @returns {string} Visual representation\n */\nexport function visualizeAudioLevel(level) {\n  const bars = Math.floor(level / 10);\n  return '█'.repeat(bars) + '░'.repeat(10 - bars);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}